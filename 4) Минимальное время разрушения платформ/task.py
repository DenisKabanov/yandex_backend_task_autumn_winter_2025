from collections import deque

def main():
    with open("input.txt", 'r') as input_file, open("output.txt", 'w') as output_file: # открываем файлы для чтения и записи
        lines = input_file.read().splitlines()
        # идея: используем две очереди, для чётных и нечётных позиций i(j), взаимодействие с которыми происходит по следующему принципу:
        # если очередь пуста — в неё вносится новый элемент
        # если не пуста, то пока пока в ней есть элементы и самый первый (левый) элемент имеет значение меньше текущего рассматриваемого — удаляем левый элемент из очереди (с обновлением соответствующих данных в time как j-i на позиции ш) и повторяем этот шаг, пока не нарушим условие (очередь не опустеет, либо встретится элемент со значением больше рассматриваемого)
        # после окончания вышеописанного цикла добавляем рассматриваемый элемент в очередь слева (в начало), как элемент с наименьшим значением
        # таким образом каждая очередь обрабатывает либо чётные, либо нечётные значения, сами они отсортированы по значению элемента (слева — наименьший, справа — наибольший)
        # и все новые рассматриваемые элементы гарантировано имеют j больше чем i (при этом этот j минимален)

        N = int(lines[0])
        time = [-1] * N # список под 

        odd = deque() # очередь для нечётных позиций
        even = deque() # очередь для чётных позиций
        for j, value in enumerate(map(int, lines[1].split())): # идём по значению и позиции его встречи (j)
            if j % 2: # odd
                while len(odd) > 0 and odd[0][1] < value: # пока слева в очереди есть элементы меньше текущего рассматриваемого (они отсортированы по значению в связи с особенностью добавления в очередь в решении)
                    i, value_ = odd.popleft() # убираем самый минимальный элемент из очереди
                    time[i] = j - i # нашли такой минимальный j, что больше i и h_i < h_j
                
                odd.appendleft((j, value)) # добавляем значение в очередь слева (так как все записи правее имеют большее значение)

            else: # even
                while len(even) > 0 and even[0][1] < value: # пока слева в очереди есть элементы меньше текущего рассматриваемого (они отсортированы по значению в связи с особенностью добавления в очередь в решении)
                    i, value_ = even.popleft() # убираем самый минимальный элемент из очереди
                    time[i] = j - i # нашли такой минимальный j, что больше i и h_i < h_j
                
                even.appendleft((j, value)) # добавляем значение в очередь слева (так как все записи правее имеют большее значение)

        print(*time, file=output_file) # записываем значения массива в файл


if __name__ == '__main__': # запускаем выполнение при прямом вызове скрипта (игнорируем при импорте этого файла в другой модуль)
    main()